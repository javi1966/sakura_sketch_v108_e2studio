/*******************************************************************************
* GR-SAKURA LIBRARY LICENSE.  LIMITATION and DISCLAIMER of WARRANTY
*
* This software is supplied by Tokushu Denshi Kairo Inc. and is only intended 
* for use with Gadget Renesas projects. No other uses are authorized.
* This software is owned by Tokuden and is protected under all applicable laws,
* including copyright laws. Disclosure or redistribution to others this headder
* file and related library file alone is not allowed.
* You can redistribute the executable object file (only SREC or BIN file) which
* is generated as a result of compilation and link your program.
* Of cource the limitation of this library license does not effect to your code.
* THIS SOFTWARE IS PROVIDED "AS IS" AND TOKUDEN MAKES NO WARRANTIES REGARDING
* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
* LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
* AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
* Tokuden reserves the right, without notice, to make changes to this software
* and to discontinue the availability of this software. By using this software,
* you agree to the additional terms and conditions found by accessing the
* http://rx.tokudenkairo.co.jp/
* (C) Copyright 2011-2012 Tokushu Denshi Kairo Inc.
*******************************************************************************/

#ifndef	__H_RXDUINO_ETHERNET
#define	__H_RXDUINO_ETHERNET
/**************************************************************************//**
 * @file     Ethernet.h
 * @brief    オンボードのLANを使うためのライブラリを使用するためのヘッダファイル。<BR>
 *           詳細は TEthernet クラス、 EthernetClient クラス、 EthernetServer クラスの説明を参照。
 ******************************************************************************/
#include "rxduino.h"
#include "tkdnip.h"
#include "../tkdnhal/tkdn_version.h"

	// 登録する関数の型は以下のとおり
	// void func( unsigned char dest_ip[4],
	// 			  unsigned char src_ip[4],
	// 			  short dest_port,
	// 			  short src_port,
	// 			  unsigned char *data, // UDPパケットのデータ部
	// 			  short datalen);      // UDPパケットのデータの長さ(ヘッダは含まない)

#define ETHERNET_LIBRARY_VERSION 0x01080000 // Version 1.08
#define ETHERNET_LIBRARY_TIME    1380466335 // 2013/09/29 23:52:15 
//------------------------------------------------------------------
// TEthernet
//------------------------------------------------------------------
/*********************************************************************//**
 *  @class   TEthernet
 *  @brief   Arduino互換のイーサネットクラス
 *  @details このクラスを使うには、include <Ethernet.h>をした後、TEthernet Ethernet;と書いてインスタンスを作る。リンカオプションで -lethernet を指定する。
 *  @note    実体は tkdnip.h をC++でカプセル化するものである。
 **********************************************************************/
class TEthernet {
private:

public:
/*********************************************************************//**
 * @brief       ライブラリのバージョン情報を取得する
 * @param[out]  vi 拡張情報が必要ならばversion_info構造体へのポインタを与える。<BR>
 *              構造体の各フィールドがセットされて戻る。各フィールドは文字列へのポインタだが、<BR>
 *              static constな文字列を指すので、ユーザプログラムでfreeしてはならない。<BR>
 *              拡張情報が不要ならばNULLを指定してもよい
 * @return      バージョン番号を1バイトずつ詰めた16進数で返す
 *              例えば、バージョン1.00ならば、0x01000000を返す
 *              バージョン1.23ならば0x010203となる。
 *              メジャーバージョン.マイナーバージョン.サブバージョン.デバッグバージョン
 **********************************************************************/
	static unsigned long getVersion(version_info *vi);

/*********************************************************************//**
 * @brief       イーサネットの受信処理を進める
 * @details     この関数が呼び出されると、受信パケットの有無を調べ、
 *              パケットの内容に応じて受信処理を進める。<BR>
 *              受信エラーの解除も行われる。
 * @warning     この関数はメインのループの中で繰り返し呼び出さなければならない。
 * @return      なし
 **********************************************************************/
	static void processPackets();

/*********************************************************************//**
 * @brief       自分のホスト名を設定する
 * @details     ここで設定したホスト名はDHCPで使われるので重要
 *              デフォルトは"GR-SAKURA"など、マクロ BOARD_NAME になっている。<BR>
 *              beginより前に呼び出すこと。
 * @param       myhostname 設定したいホスト名
 * @return      なし
 **********************************************************************/
	void setHostname(const char *myhostname);

/*********************************************************************//**
 * @brief       イーサネットライブラリを開始する
 * @details     IPアドレス、ネームサーバ、デフォルトゲートウェイ、サブネットマスクはDHCPで取得される。
 * @param       mac MACアドレス
 * @return      成功したら1を返す。失敗したら0を返す。
 **********************************************************************/
	int  begin(byte mac[6]);

/*********************************************************************//**
 * @brief       イーサネットライブラリを開始する
 * @details     ネームサーバ、デフォルトゲートウェイ、サブネットマスクはDHCPで取得される。
 * @param       mac MACアドレス
 * @param       ip IPアドレス
 * @return      なし
 **********************************************************************/
	void begin(byte mac[6], byte ip[4]); 

/*********************************************************************//**
 * @brief       イーサネットライブラリを開始する
 * @details     デフォルトゲートウェイ、サブネットマスクはDHCPで取得される。
 * @param       mac MACアドレス
 * @param       ip IPアドレス
 * @param       dns ネームサーバのアドレス
 * @return      なし
 **********************************************************************/
	void begin(byte mac[6], byte ip[4], byte dns[4]); 

/*********************************************************************//**
 * @brief       イーサネットライブラリを開始する
 * @details     サブネットマスクはDHCPで取得される。
 * @param       mac MACアドレス
 * @param       ip IPアドレス
 * @param       dns ネームサーバのアドレス
 * @param       gateway デフォルトゲートウェイのアドレス
 * @return      なし
 **********************************************************************/
	void begin(byte mac[6], byte ip[4], byte dns[4], byte gateway[4]); 

/*********************************************************************//**
 * @brief       イーサネットライブラリを開始する
 * @details     MACアドレス、IPアドレス、DNS、デフォルトゲートウェイ、サブネットマスクを指定してイーサネットライブラリを開始する
 * @param       mac MACアドレス
 * @param       ip IPアドレス
 * @param       dns ネームサーバのアドレス
 * @param       gateway デフォルトゲートウェイのアドレス
 * @param       subnet サブネットマスク
 * @return      なし
 **********************************************************************/
	void begin(byte mac[6], byte ip[4], byte dns[4], byte gateway[4], byte subnet[4]); 

/*********************************************************************//**
 * @brief       自分のIPアドレスを文字列にして受け取る
 * @note        返される文字列はライブラリの中でstaticに確保された領域にあるので、ユーザプログラムでfreeしないこと。
 * @return      自分のIPアドレス
 * @warning     返された文字列をfreeしないこと
 **********************************************************************/
	char *localIP();

/*********************************************************************//**
 * @brief       LANがリンクアップしているかどうかを返す
 * @note        RXduinoの拡張。Arduinoにはない。
 * @return      自分のIPアドレス
 **********************************************************************/
	bool isLinkup();

/*********************************************************************//**
 * @brief       ターゲットホスト名を指定してPingを送る
 * @param       hostname Pingを送りたいホスト名 (例 : "www.tokudenkairo.co.jp")
 * @return      1回でも成功したらtrueを返す。すべて失敗したらfalseを返す
 **********************************************************************/
	bool Ping(const char *hostname);

/*********************************************************************//**
 * @brief       ターゲットのIPアドレスを指定してPingを送る
 * @param       ip Pingを送りたいIPアドレス
 * @return      1回でも成功したらtrueを返す。すべて失敗したらfalseを返す
 **********************************************************************/
	bool Ping(byte ip[4]);

/*********************************************************************//**
 * @brief       DNSにアクセスして、ホスト名からIPアドレスを調べる
 * @param       hostname 調べたいホスト名 (例 : "www.tokudenkairo.co.jp")
 * @return      成功したらIPアドレスが格納された配列を返す。失敗したら0.0.0.0が格納された配列を返す
 * @note        返される4バイトの配列はライブラリ内でstaticに確保された領域にある
 * @warning     返された配列をfreeしないこと
 **********************************************************************/
	byte *gethostbyname(const char *hostname);

/*********************************************************************//**
 * @brief       DHCPでIPアドレスやDNS、ゲートウェイ等の取得を再実行する
 * @return      成功したらtrueを返す。失敗したらfalseを返す。
 * @note        取得したIPアドレスは localIP() 関数で調べる
 **********************************************************************/
	bool dhcp(void);

/*********************************************************************//**
 * @brief       UDPパケットを送る
 * @param[in]   ipaddr 送信先のIPアドレスが格納された配列
 * @param[in]   dest_port 送信先のポート番号
 * @param[in]   buf 送信したいデータが格納されたバッファ
 * @param[in]   len 送信したいデータの長さ
 * @return      成功したらtrueを返す。失敗したらfalseを返す。
 **********************************************************************/
	bool sendUDP(byte ipaddr[4],unsigned short dest_port,byte *buf,int len);

	// 
/*********************************************************************//**
 * @brief       UDPを受信したときにコールバックされる関数を登録する
 * @details     この関数は tketh_regist_udp_handler() を呼び出しているにすぎない。引数の UDP_HANDLE_FUNC 型関数ポインタについての説明は tkdnip.h を参照。
 * @param[in]   func UDPを受信したときにコールバックされる関数。
 * @details     登録された関数がTRUEを返すとユーザで処理したものと解釈され、システムでは処理されない。FALSEを返すとシステムで処理される。
 * @note        登録される関数は processPackets() の中から呼び出される。したがって、processPackets()を繰り返し呼び出していないと受信処理は行われない。
 * @include     udprecv.cpp
 **********************************************************************/
	void registUdpHandler(UDP_HANDLE_FUNC func);
};

extern TEthernet Ethernet;

/*********************************************************************//**
 *  @class   EthernetClient
 *  @brief   Arduino互換のTCPクライアント・クラス
 *  @details このクラスを使うには、include <Ethernet.h>をした後、EthernetClient client;と書いてインスタンスを作る。
 **********************************************************************/
class EthernetClient {
private:
	tcp_t *info;
	bool istmp;

public:
/*********************************************************************//**
 * @brief       ライブラリのバージョン情報を取得する
 * @param[out]  vi 拡張情報が必要ならばversion_info構造体へのポインタを与える。<BR>
 *              構造体の各フィールドがセットされて戻る。各フィールドは文字列へのポインタだが、<BR>
 *              static constな文字列を指すので、ユーザプログラムでfreeしてはならない。<BR>
 *              拡張情報が不要ならばNULLを指定してもよい
 * @return      バージョン番号を1バイトずつ詰めた16進数で返す
 *              例えば、バージョン1.00ならば、0x01000000を返す
 *              バージョン1.23ならば0x010203となる。
 *              メジャーバージョン.マイナーバージョン.サブバージョン.デバッグバージョン
 **********************************************************************/
	static unsigned long getVersion(version_info *vi);

	EthernetClient();
	EthernetClient(tcp_t *info);
	~EthernetClient();

/*********************************************************************//**
 * @brief       サーバに接続する
 * @param[in]   server 接続したいサーバのIPアドレス
 * @param[in]   port 接続したいポート番号
 * @return      成功したらtrueを返す。失敗したらfalseを返す。
 * @note        この関数は接続に失敗したら自分のポート番号を変えて4回まで試行するので、失敗した分だけサーバにSYN_RCVDが残ってしまう。
 **********************************************************************/
	bool connect(byte server[4],unsigned short port);

/*********************************************************************//**
 * @brief       TCPで接続しているかどうか調べる
 * @return      接続していたらtrueを返す。接続していなかったらfalseを返す。
 **********************************************************************/
	bool connected();

/*********************************************************************//**
 * @brief       TCPで接続していればFINを送って、コネクションを閉じる
 * @return      なし
 **********************************************************************/
	void stop();

/*********************************************************************//**
 * @brief       接続している相手先に1バイトのデータを送信する
 * @param[in]   c 送信したいデータ 0x00～0xff
 * @return      なし
 **********************************************************************/
	void write(unsigned char c);

/*********************************************************************//**
 * @brief       接続している相手先に文字列を送信する
 * @param[in]   str 送信したい文字列
 * @return      なし
 **********************************************************************/
	void write(const char *str);

/*********************************************************************//**
 * @brief       接続している相手先に長さを指定してバイナリデータを送る
 * @param[in]   buf 送信したいデータが格納されたバッファ
 * @param[in]   len 送信したいデータ長
 * @return      なし
 **********************************************************************/
	void write(unsigned char *buf,int len);

/*********************************************************************//**
 * @brief       接続している相手先に型式を指定して、文字列として数値を送る
 * @param[in]   val 送りたい数値
 * @param[in]   print_type BYTE BIN DEC HEX OCT から指定する。
 * @return      なし
 **********************************************************************/
	void print(int val, int print_type=DEC);

/*********************************************************************//**
 * @brief       接続している相手先に浮動小数点数を文字列として送る
 * @param[in]   val 送りたい数値
 * @param[in]   fpdigit 小数点以下の桁数
 * @note        この関数はまだ実装されていない
 * @return      なし
 **********************************************************************/
	void print(double val, int fpdigit=2);

/*********************************************************************//**
 * @brief       接続している相手先に文字列を送る
 * @param[in]   str 送りたい文字列
 * @return      なし
 **********************************************************************/
	void print(const char *str);

/*********************************************************************//**
 * @brief       接続している相手先に改行コードを送る
 * @return      なし
 **********************************************************************/
	void println(void);

/*********************************************************************//**
 * @brief       接続している相手先に型式を指定して、文字列として数値を送り、改行を送る
 * @param[in]   val 送りたい数値
 * @param[in]   print_type BYTE BIN DEC HEX OCT から指定する。
 * @return      なし
 **********************************************************************/
	void println(int val, int print_type=DEC);

/*********************************************************************//**
 * @brief       接続している相手先に浮動小数点数を文字列として送り、改行を送る
 * @param[in]   val 送りたい数値
 * @param[in]   fpdigit 小数点以下の桁数
 * @note        この関数はまだ実装されていない
 * @return      なし
 **********************************************************************/
	void println(double val, int fpdigit=2);

/*********************************************************************//**
 * @brief       接続している相手先に文字列を送り、改行を送る
 * @param[in]   str 送りたい文字列
 * @return      なし
 **********************************************************************/
	void println(const char *str);

/*********************************************************************//**
 * @brief       接続している相手先から受け取ったデータがあるかどうかを調べる
 * @return      受信バッファに格納されているデータ数
 **********************************************************************/
	int available();

/*********************************************************************//**
 * @brief       受信したデータを1文字取り出す
 * @return      読み出したデータ。データがなければ-1を返す。
 * @note        この関数が呼び出されてバッファに空きが生じると、windowサイズの更新のためのACKが送られる
 **********************************************************************/
	int read();

/*********************************************************************//**
 * @brief       この関数は実装されていない
 **********************************************************************/
	void flush();

	operator int();  //!< @brief クライアントが存在していたら1。失敗していたら0。
	operator bool(); //!< @brief クライアントが存在していたらtrue。失敗していたらfalse。

};

/*********************************************************************//**
 *  @class   EthernetServer
 *  @brief   Arduino互換のTCPサーバ・クラス
 *  @details このクラスを使うには、#include <Ethernet.h>をした後、EthernetServer server(ポート番号);と書いてインスタンスを作る。
 **********************************************************************/
class EthernetServer {
private:
	tcp_t *info;

public:
/*********************************************************************//**
 * @brief       ライブラリのバージョン情報を取得する
 * @param[out]  vi 拡張情報が必要ならばversion_info構造体へのポインタを与える。<BR>
 *              構造体の各フィールドがセットされて戻る。各フィールドは文字列へのポインタだが、<BR>
 *              static constな文字列を指すので、ユーザプログラムでfreeしてはならない。<BR>
 *              拡張情報が不要ならばNULLを指定してもよい
 * @return      バージョン番号を1バイトずつ詰めた16進数で返す
 *              例えば、バージョン1.00ならば、0x01000000を返す
 *              バージョン1.23ならば0x010203となる。
 *              メジャーバージョン.マイナーバージョン.サブバージョン.デバッグバージョン
 **********************************************************************/
	static unsigned long getVersion(version_info *vi);

/*********************************************************************//**
 * @brief       サーバクラスのコンストラクタ
 * @param[in]   port 接続を待ちうけるポート番号
 * @details     コンストラクタはあくまでも準備をするだけ。実際にLISTENステートには入れない。
 **********************************************************************/
	EthernetServer(unsigned short port);
	~EthernetServer();

/*********************************************************************//**
 * @brief       サーバの接続待ちを開始する
 * @details     実際にLISTEN状態にし、SYNを待ちうける
 **********************************************************************/
	void begin();

/*********************************************************************//**
 * @brief       サーバに接続していて受信データのあるクライアントのオブジェクトを返す
 * @return      接続していれば、接続しているクライアントのオブジェクト<BR>
 *              接続していなければ、0やfalseを返す。
 * @note        この関数が返す型はクライアントクラスであるが、クライアントクラスがint型やbool型にキャストされるため、0やfalseを返す。
 **********************************************************************/
	EthernetClient available();

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに1バイトのデータを送信する
 * @param[in]   c 送信したいデータ 0x00～0xff
 * @return      なし
 **********************************************************************/
	void write(unsigned char c);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに文字列を送信する
 * @param[in]   str 送信したい文字列
 * @return      なし
 **********************************************************************/
	void write(const char *str);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに長さを指定してバイナリデータを送る
 * @param[in]   buf 送信したいデータが格納されたバッファ
 * @param[in]   len 送信したいデータ長
 * @return      なし
 **********************************************************************/
	void write(unsigned char *buf,int len);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに型式を指定して、文字列として数値を送る
 * @param[in]   val 送りたい数値
 * @param[in]   print_type BYTE BIN DEC HEX OCT から指定する。
 * @return      なし
 **********************************************************************/
	void print(int val, int print_type=DEC);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに浮動小数点数を文字列として送る
 * @param[in]   val 送りたい数値
 * @param[in]   fpdigit 小数点以下の桁数
 * @note        この関数はまだ実装されていない
 * @return      なし
 **********************************************************************/
	void print(double val, int fpdigit=2);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに文字列を送る
 * @param[in]   str 送りたい文字列
 * @return      なし
 **********************************************************************/
	void print(const char *str);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに改行コードを送る
 * @return      なし
 **********************************************************************/
	void println();

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに型式を指定して、文字列として数値を送り、改行を送る
 * @param[in]   val 送りたい数値
 * @param[in]   print_type BYTE BIN DEC HEX OCT から指定する。
 * @return      なし
 **********************************************************************/
	void println(int val, int print_type=DEC);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに浮動小数点数を文字列として送り、改行を送る
 * @param[in]   val 送りたい数値
 * @param[in]   fpdigit 小数点以下の桁数
 * @note        この関数はまだ実装されていない
 * @return      なし
 **********************************************************************/
	void println(double val, int fpdigit=2);

/*********************************************************************//**
 * @brief       接続しているすべてのクライアントに文字列を送り、改行を送る
 * @param[in]   str 送りたい文字列
 * @return      なし
 **********************************************************************/
	void println(const char *str);

};

#endif // __H_RXDUINO_ETHERNET

